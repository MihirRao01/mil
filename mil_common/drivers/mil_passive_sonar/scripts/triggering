#!/usr/bin/env python
import rospy
import numpy as np
from rospy.numpy_msg import numpy_msg
from std_msgs.msg import Header
from std_srvs.srv import SetBool, SetBoolResponse
from std_srvs.srv import Trigger, TriggerResponse
from mil_passive_sonar.msg import HydrophoneSamples, Ping2
from mil_passive_sonar.srv import SetTargetFrequency, SetTargetFrequencyResponse
from mil_passive_sonar import util
from mil_ros_tools import Plotter, interweave

from scipy.signal import fftconvolve
from scipy.ndimage.filters import maximum_filter1d


class HydrophoneTrigger:

    def __init__(self):
        '''ROS Node meant to trigger only when a ping happens in our target frequency range

        Subscribes to raw hydrophone samples on `samples`

        publishes samples(of gradient) from right around the triggering on `pings` when a ping is detected
            and found to be in the target frequency range

        publish a plot of the frequency response of the filter on `/filter_debug`  by service calling `/filter_debug_trigger`

        '''

        # Ros stuff
        rospy.init_node('hydrophone_trigger')
        self.sub = rospy.Subscriber('samples', numpy_msg(HydrophoneSamples), self.hydrophones_cb)
        self.pub = rospy.Publisher('pings', numpy_msg(Ping2), queue_size=1)
        rospy.Service('~filter_debug_trigger', Trigger, self.filter_response)
        rospy.Service('~enable', SetBool, self.enable)

        self.enabled = True

        # Attriburtes about our general frequency range (all pinger live here)
        #  Frequency range garunteed to be relatively quiet except for the pingers (in Hz)
        self.general_lower = 15000 # lowest frequency pinger - 10 kHz
        self.general_upper = 50000 # highest frequency pinger + 10 kHz

        # Attributes about our target frequency range
        #  target Frquency in Hz
        self.target = rospy.get_param('~target_frequency')
        #  tolerance around that frequerncy in Hz
        self.tolerance = rospy.get_param('~frequency_tolerance')
        # rate of the samples, not expected to change
        self.rate = None

        # Filter attributes
        #  Filter order for bandpass filter, (higher is better, but slower to compute)
        self.filt_order = rospy.get_param('~filter_order')
        #  Filter used to do a band pass filter for our general frquency range, calcuated on first cb
        self.bandpass_filter = None
        #  special filter property, do not change in Hz
        self.trans_width = 500

        # Physical Properties
        # min time between pings (of any kind) in sec
        self.min_time_between_pings = rospy.get_param('~min_time_between_pings')
        self.prev_trigger_time = -1 * self.min_time_between_pings
        self.dist_h = rospy.get_param('dist_h')
        self.v_sound = rospy.get_param('v_sound')

        # Debug attributes
        #  Debug plot publishers
        self.trigger_debug = Plotter('~trigger_debug')
        self.sample_at_trigger_debug = Plotter('~sample_at_trigger_debug')
        self.filter_debug = Plotter('~filter_debug')

        # Misc attributes
        #  minimum gradient of the max convolution wrt time to trigger a time of arivals calcualtion
        self.threshold = 5

        self.trigger_offset = rospy.get_param('~trigger_offset')
        #  how far after the triggering time to make upper bound of samples at triggering in sec
        self.trigger_window_future = 1.0 * (self.dist_h / self.v_sound)
        #  how far before the triggering time to make lower bound of samples at triggering in sec
        self.trigger_window_past = 1.0 * (self.dist_h / self.v_sound)
        # time (from start of samples)
        self.time = 0.0
        #  max convolution window, the amount of time that we assume should be quiet before a ping in sec
        #  NOTE: maxes out at (sample_rate * samples) (currently maxed out)
        self.window_time = rospy.get_param('~max_convolve_window')
        #  prev data buffer
        self.prev_data = None


    def enable(self, req):
        self.enabled = req.data
        res = SetBoolResponse()
        res.success = True
        return res

    def filter_response(self, req):
        res = TriggerResponse()
        if self.bandpass_filter is None:
            res.message = 'filter has not yet been created (created on the first callback after target being set)'
            res.success = False
            return res
        x, y = util.find_freq_response(self.bandpass_filter, self.rate, self.general_lower, self.general_upper)
        plots = np.vstack((x, y))
        titles = ['frequency (Hz)  vs Gain (dB)']
        self.filter_debug.publish_plots(plots, titles=titles)
        res.success = True
        return res


    def hydrophones_cb(self, msg):
        # Record start time of cb to make sure we are running in real time
        start_cb = rospy.get_rostime()

        # if not enabled, go no further
        if not self.enabled:
            return

        # Target must be set
        if self.bandpass_filter is None and self.target is not None:
            self.rate = msg.sample_rate
            self.bandpass_filter = util.make_bandpass_filter(self.target-self.tolerance,
                                                             self.target+self.tolerance,
                                                             msg.sample_rate, self.filt_order, self.trans_width)

        elif self.bandpass_filter is None:
            return

        # Resize the 1d array to be a 2d array of samples by channels
        msg.data.resize(msg.samples, msg.channels)

        # Apply a bandpass filter to the data for our general frequency range (on all channels)
        new_data = np.apply_along_axis(lambda x: fftconvolve(x, self.bandpass_filter, 'valid'),
            0, msg.data)

        # We always look at 2 messages of data at a time concatenated (0.1 sec each msg (for sylphase board))
        if self.prev_data is None:
            self.prev_data = new_data
            return
        else:
            data = np.concatenate((self.prev_data, new_data))
        # Time according to the passive sonar interface (assuming no missed messages)
        time = np.linspace(self.time, self.time + data.shape[0]/float(msg.sample_rate),
            data.shape[0])

        window_size = int(self.window_time * msg.sample_rate)

        # only use hydrophone 0 to trigger, more efficient
        # do a max convolution on the data
        max_convolves = np.apply_along_axis(lambda x: maximum_filter1d(x, window_size, axis=0),
            0, data)
        max_convolve = max_convolves[:,0]
        #  NOTE: No need to crop because zero padding is used and we are doing a max convolution

        # take the gradient of the max convolution (we are looking for steep increase = big gradient)
        gradients = np.gradient(max_convolves, axis=0)
        gradient = gradients[:,0]

        if np.max(gradient) >= self.threshold:

            # offset by (window size - 1) /2 because the ouput of the convolution is centered on the window
            triggered_at_idx = np.min(np.where(gradient >= self.threshold)[0])# + (window_size-1)/2
            triggered_at_idx += int(self.trigger_offset * msg.sample_rate)
            trigger_time = time[triggered_at_idx]

            # if we have triggered very recently, do not trigger (echo protection)
            if trigger_time - self.prev_trigger_time > self.min_time_between_pings:

                self.prev_trigger_time = trigger_time

                start = triggered_at_idx - int(msg.sample_rate*self.trigger_window_past)
                end = triggered_at_idx + int(msg.sample_rate*self.trigger_window_future)

                ping_data = gradients[start:end]

                triggered_at_sample = triggered_at_idx + (window_size-1)/2
                start_sample = triggered_at_sample - int(50 * msg.sample_rate*self.trigger_window_past)
                end_sample = triggered_at_sample + int(50 * msg.sample_rate*self.trigger_window_future)
                ping_samples = data[start_sample:end_sample]

                freq = util.find_freq(ping_samples, msg.sample_rate)
                try:
                    freq = util.find_freq(ping_samples, msg.sample_rate)
                except Exception as e:
                    rospy.logwarn('/hydrophone/triggering in find_freq %s'%e)
                    freq = self.target
                rospy.loginfo('triggered at %f on %f Hz'%(trigger_time, freq))

                ping = Ping2()
                ping.header = Header()
                ping.header.stamp = rospy.Time.now()
                ping.channels = msg.channels
                ping.samples = end - start
                ping.sample_rate = msg.sample_rate
                ping.data = ping_data.flatten()
                ping.ping_time = -1 * (trigger_time -\
                                 ((2*trigger_time - self.trigger_window_past + self.trigger_window_future) / 2))
                self.pub.publish(ping)

                if self.trigger_debug.is_go():
                    plot_data = data[:,0]
                    titles = ['time vs Gradient of Max convolve',
                              'time vs max_convolve (Window = %s sec)'%self.window_time,
                              'time vs hydrophone0 data']
                    plotable = np.vstack((gradient, max_convolve, plot_data))
                    plots = interweave(time, plotable)
                    self.trigger_debug.publish_plots(plots, titles)

                if self.sample_at_trigger_debug.is_go():
                    plot_time = time[start_sample:end_sample]
                    plots = interweave(plot_time, ping_samples.transpose())
                    self.sample_at_trigger_debug.publish_plots(plots)

        self.time += msg.samples / float(msg.sample_rate)
        self.prev_data = new_data

        spare_time = (float(msg.samples) / msg.sample_rate) - (rospy.get_rostime() - start_cb).to_sec()

        if spare_time < 0:
            rospy.logerr('Spare Time After Callback: %f, Running slower than real time'%spare_time)


if __name__ == '__main__':
    a = HydrophoneTrigger()
    rospy.spin()


